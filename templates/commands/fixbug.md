---
description: 从 Bug 描述或 GitHub Issue 出发，通过四阶段子代理流水线定位、分析、修复、验证问题
argument-hint: <bug描述> 或 issue:#123 或 issue:https://github.com/owner/repo/issues/123
---

## User Input

```text
$ARGUMENTS
```

## Spec-FixBug: Four-Stage Bug Fix Pipeline

### Load Project Config

Read `.specify/.project` to load project-specific settings (generated by `/speckit.init`):

```bash
source .specify/.project
```

This provides: `STACK`, `BUILD_COMMAND`, `TEST_COMMAND`, `TEST_DIR`, `DEPLOY_COMMAND`,
`APP_PORT`, `DOC_PATH`, `MIGRATION_TOOL`, `MIGRATION_PATH`, `SERVICE_LOG_COMMAND`, etc.

If `.specify/.project` does not exist, warn the user:
```
WARNING: .specify/.project not found. Run /speckit.init first to detect project config.
```
Then fall back to asking the user for BUILD_COMMAND and TEST_COMMAND before proceeding.

### Subagent Timeout and Chunked Write (Constitution v2.4.0)

- **5-minute hard timeout**: Every subagent call (Task tool) MUST set timeout=300. If a
  subagent has not returned within 5 minutes, MUST stop the call and follow the procedure
  below.
- **Chunked write instruction**: Every subagent prompt MUST include the following reminder:
  "When writing large files (>150 lines), you MUST write in chunks (each chunk <=150 lines)
  to avoid blocking that causes timeouts. Use Create for the first chunk, then Edit to
  append subsequent chunks."
- **Timeout handling procedure**:
  1. Record the timed-out TaskID and known progress.
  2. Split the task into smaller sub-tasks if the original scope was too broad.
  3. Re-dispatch with reduced scope and the chunked-write reminder.
  4. After 2 consecutive timeouts on the same task, halt and report to the user.

### Pipeline Overview

```
Phase 1: Gather Bug Context   (fixbug — no subagent)
Phase 2: Log Analysis          (log-analyzer)
Phase 3: Locate                (bug-locator)     ← Read-only
Phase 4: Analyze               (bug-analyzer)    ← Read-only
Phase 5: Fix                   (bug-fixer)       ← Write access
Phase 5.5: Impact Analysis     (impact-analyzer) ← Read-only
Phase 6: Verify                (bug-verifier)    ← Bash access
Phase 7: Report                (fixbug — no subagent)
```

Permission escalation: Locator/Analyzer are read-only → Fixer gains write → Verifier gains bash.
Each agent receives only the structured report from the previous stage + original bug context.

---

### Phase 1: Gather Bug Context

**1a. Parse Input**

Determine input type from `$ARGUMENTS`:

- **GitHub Issue URL** (contains `github.com` and `/issues/`):
  Extract owner, repo, issue number. Fetch issue via GitHub MCP tool or `gh issue view`.
- **Issue shorthand** (`issue:#123` or `#123`):
  Detect repo from `git remote get-url origin`. Fetch issue details.
- **Plain text description**:
  Use directly as bug description.

**1b. Extract Bug Information**

From the issue or description, extract:
- **Summary**: One-line description of the bug
- **Reproduction steps**: How to trigger the bug
- **Expected behavior**: What should happen
- **Actual behavior**: What actually happens
- **Environment**: Version, OS, config (if mentioned)
- **Error messages**: Any error text, stack traces, or screenshots mentioned
- **Affected module**: Which part of the system is involved

If critical information is missing, ask the user (max 3 questions):
- "How do you trigger this bug?"
- "What error message or behavior do you see?"
- "When did this start happening?"

**1c. Show Bug Summary**

```
============================================================
Bug Investigation: <summary>

Source: <GitHub Issue #N / User description>
Module: <detected or unknown>
Reproduction: <steps or "not provided">
Error: <error message snippet or "not provided">

Starting four-stage pipeline...
============================================================
```

Store variables for downstream agents:
- `BUG_SUMMARY` — one-line summary
- `ERROR_MESSAGES` — extracted error text / stack traces
- `REPRO_STEPS` — reproduction steps
- `AFFECTED_MODULE` — module name or "unknown"

---

### Phase 2: Log Analysis

**2a. Determine Log Source**

The fixbug command (not the log-analyzer) is responsible for locating the log source.
Check in priority order:

1. If `${SERVICE_LOG_COMMAND}` is non-empty → use it as the log retrieval command
2. Check common log paths: `logs/`, `log/`, `*.log`
3. Check Docker: `docker compose logs --tail=500`
4. None found → set `LOG_FINDINGS = "N/A"` and skip to Phase 3

Record the resolved log source as `LOG_SOURCE` (a file path or shell command).

**2b. Dispatch Log Analyzer**

```
Task:
  subagent_type: log-analyzer
  timeout: 300
  description: "Analyze logs for bug: <BUG_SUMMARY>"
  prompt: |
    Log source: <LOG_SOURCE>
    Investigation context:
      Summary: <BUG_SUMMARY>
      Error message: <ERROR_MESSAGES>
      Affected module: <AFFECTED_MODULE>
      Reproduction: <REPRO_STEPS>
    Stack hint: ${STACK}
    Service log command: ${SERVICE_LOG_COMMAND}

    Focus on:
    1. Errors matching the reported bug symptoms
    2. Stack traces related to the affected module
    3. Timeline of events around the bug occurrence
    4. Any correlated warnings or errors

    Return your standard Log Analysis Report.

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts.
```

**2c. Parse Log Findings**

Extract from the log analysis and store as `LOG_FINDINGS`:
- Relevant error messages and stack traces
- Timestamps and frequency
- Root cause hypothesis from logs

If log-analyzer returned nothing useful, set `LOG_FINDINGS = "N/A"`.

---

### Phase 3: Locate (bug-locator)

**3a. Dispatch Bug Locator**

```
Task:
  subagent_type: bug-locator
  timeout: 300
  description: "Locate bug: <BUG_SUMMARY>"
  prompt: |
    ## Bug Location Request

    Bug summary: <BUG_SUMMARY>
    Error messages: <ERROR_MESSAGES>
    Stack traces: <extracted stack traces from ERROR_MESSAGES and LOG_FINDINGS>
    Log findings: <LOG_FINDINGS>
    Stack/framework hint: ${STACK}

    Search the codebase to find where this bug originates. Focus on:
    1. Function/class names from stack traces
    2. Error message strings in source code
    3. The affected module: <AFFECTED_MODULE>
    4. Related configuration or data flow

    Return your standard Bug Location Report with:
    - Most Likely Location (file, function, line, confidence)
    - Related Code files
    - Handoff notes for the analyzer

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts.
```

**3b. Parse Location Report**

Extract and store:
- `SUSPECTED_FILE` — primary file path
- `SUSPECTED_FUNCTION` — function/method name
- `SUSPECTED_LINE` — approximate line number
- `CONFIDENCE` — High / Medium / Low
- `RELATED_FILES` — list of related file paths
- `HANDOFF_NOTES` — what the analyzer should focus on

**3c. Checkpoint: Low Confidence**

If `CONFIDENCE` = Low AND `SUSPECTED_FILE` is empty or vague:
```
The locator could not pinpoint the bug with confidence.

Suspected area: <SUSPECTED_FILE or "unknown">
Confidence: Low

Can you provide additional context?
  - Specific file or module where you suspect the bug
  - Steps to reproduce more precisely
  - Recent changes that might have introduced it
```
Wait for user input, then re-dispatch bug-locator with the additional context.
Max 1 retry — if still Low after retry, proceed with best guess and note uncertainty.

---

### Phase 4: Analyze (bug-analyzer)

**4a. Dispatch Bug Analyzer**

```
Task:
  subagent_type: bug-analyzer
  timeout: 300
  description: "Analyze bug: <BUG_SUMMARY>"
  prompt: |
    ## Bug Analysis Request

    ### Location Report (from Locator)
    File: <SUSPECTED_FILE>
    Function: <SUSPECTED_FUNCTION>
    Line: <SUSPECTED_LINE>
    Confidence: <CONFIDENCE>
    Related files: <RELATED_FILES>
    Locator notes: <HANDOFF_NOTES>

    ### Bug Context
    Summary: <BUG_SUMMARY>
    Error messages: <ERROR_MESSAGES>
    Log findings: <LOG_FINDINGS>
    Stack/framework hint: ${STACK}

    Deeply analyze the root cause. Read the suspected file and trace the
    execution flow. Return your standard Bug Analysis Report with:
    - Root Cause explanation
    - Bug Category
    - Severity and Impact Assessment
    - Fix Complexity estimate
    - Recommended Approach for the fixer
    - Watch Out warnings

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts.
```

**4b. Parse Analysis Report**

Extract and store:
- `ROOT_CAUSE` — clear explanation of why the bug occurs
- `BUG_CATEGORY` — Logic Error / Type Error / Race Condition / Edge Case / Resource Leak / Other
- `SEVERITY` — Critical / High / Medium / Low
- `FIX_COMPLEXITY` — Simple / Moderate / Complex
- `RECOMMENDED_APPROACH` — brief guidance for the fixer
- `WATCH_OUT` — potential pitfalls during fix

**4c. Checkpoint: User Confirmation**

```
============================================================
Bug Diagnosis (from Analyzer)

Root Cause:
  <ROOT_CAUSE>

Category: <BUG_CATEGORY>
Severity: <SEVERITY>
Fix Complexity: <FIX_COMPLEXITY>

Location:
  <SUSPECTED_FILE>:<SUSPECTED_LINE> → <SUSPECTED_FUNCTION>

Recommended Approach:
  <RECOMMENDED_APPROACH>

Watch Out:
  <WATCH_OUT>
============================================================

Proceed with fix? (yes / no / alternative)
  yes         — Apply the recommended fix
  no          — Stop, I'll fix manually
  alternative — Suggest a different approach
```

If user says "alternative", incorporate their suggestion into `RECOMMENDED_APPROACH` before
proceeding to Phase 5.

---

### Phase 5: Fix (bug-fixer)

**5a. Create Fix Branch (optional)**

If not already on a feature branch:
```bash
git checkout -b fix/<short-bug-description>
```

**5b. Dispatch Bug Fixer**

```
Task:
  subagent_type: bug-fixer
  timeout: 300
  description: "Fix bug: <BUG_SUMMARY>"
  prompt: |
    ## Bug Fix Request

    ### Analysis Report (from Analyzer)
    Root cause: <ROOT_CAUSE>
    Bug category: <BUG_CATEGORY>
    Severity: <SEVERITY>
    Recommended approach: <RECOMMENDED_APPROACH>
    Watch out: <WATCH_OUT>

    ### Location
    Primary file: <SUSPECTED_FILE>
    Function: <SUSPECTED_FUNCTION>
    Line: <SUSPECTED_LINE>
    Related files: <RELATED_FILES>

    ### Context
    Bug summary: <BUG_SUMMARY>
    Stack/framework hint: ${STACK}

    Implement the fix following the recommended approach. Apply MINIMAL changes.
    Do NOT run build or tests — verification is handled by a separate agent.

    Return your standard Bug Fix Report with:
    - Changed files list
    - Fix explanation
    - Potential side effects
    - Testing notes for the verifier
    - Rollback plan

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts. Use Create for the
    first chunk, then Edit to append.
```

**5c. Parse Fix Report**

Extract and store:
- `CHANGED_FILES` — list of modified file paths
- `FIX_EXPLANATION` — why this fix works
- `SIDE_EFFECTS` — any code that might be affected
- `TESTING_NOTES` — what the verifier should check
- `ROLLBACK_PLAN` — how to revert if needed

---

### Phase 5.5: Impact Analysis (impact-analyzer)

This is NOT part of the four-stage bug pipeline — it is a general-purpose change impact
analysis that runs between Fix and Verify.

```
Task:
  subagent_type: impact-analyzer
  timeout: 300
  description: "Impact analysis for bug fix: <BUG_SUMMARY>"
  prompt: |
    Working directory: <repo root>

    A bug fix has been applied. Analyze the impact of these changes:

    1. Run: git diff HEAD (to get the fix diff)
    2. Trace all callers of modified functions/APIs
    3. Check if the fix changes any public interface or behavior contract
    4. Verify no downstream modules are broken by the fix
    5. Flag if the fix touches areas with prior incidents
    6. Cross-reference with chain-topology.md and incident-log.md (if they exist
       under .specify/knowledge-base/)

    Bug context:
      Summary: <BUG_SUMMARY>
      Root cause: <ROOT_CAUSE>
      Files changed: <CHANGED_FILES>

    Output your standard Impact Analysis Report.

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts.
```

**Handle impact results:**
- **No HIGH/CRITICAL risks** → proceed to Phase 6
- **Risks found** → show to user before verification:
  ```
  Impact analysis found potential side effects from the fix:
  - [SEVERITY] <risk description>

  Options:
    proceed  — Continue with verification (risks accepted)
    revise   — Adjust the fix to address risks (re-dispatch bug-fixer)
    stop     — Halt for manual review
  ```

If user chooses "revise", re-dispatch bug-fixer (Phase 5b) with the impact risks appended
to the prompt as additional constraints.

**Knowledge Feedback**: If the impact report discovered new call chain information,
update `chain-topology.md`. If the bug itself is noteworthy, append to `incident-log.md`
with date, severity, affected module, root cause, resolution, and lesson learned.

---

### Phase 6: Verify (bug-verifier)

**6a. Dispatch Bug Verifier**

```
Task:
  subagent_type: bug-verifier
  timeout: 300
  description: "Verify fix: <BUG_SUMMARY>"
  prompt: |
    ## Bug Fix Verification Request

    ### Fix Report (from Fixer)
    Changed files: <CHANGED_FILES>
    Fix explanation: <FIX_EXPLANATION>
    Side effects: <SIDE_EFFECTS>
    Testing notes: <TESTING_NOTES>

    ### Commands
    Build command: ${BUILD_COMMAND}
    Test command: ${TEST_COMMAND}
    Stack/framework hint: ${STACK}

    ### Bug Context
    Summary: <BUG_SUMMARY>
    Root cause: <ROOT_CAUSE>

    Verify the fix:
    1. Run the build command (if non-empty)
    2. Run the test command (if non-empty)
    3. Check that the original bug scenario is addressed
    4. Check for regressions in changed files and related areas

    Return your standard Verification Report with:
    - Test Status (PASS/FAIL)
    - Fix Status (FIXED/NOT FIXED/PARTIALLY FIXED)
    - Regression Found (Yes/No)
    - Final Verdict (Safe to merge / Needs more work / Needs manual testing)

    WARNING: When writing large files (>150 lines), you MUST write in chunks
    (each chunk <=150 lines) to avoid blocking timeouts.
```

**6b. Parse Verification Report**

Extract:
- `TEST_STATUS` — PASS / FAIL / SKIPPED
- `FIX_STATUS` — FIXED / NOT FIXED / PARTIALLY FIXED
- `REGRESSION_FOUND` — Yes / No
- `FINAL_VERDICT` — Safe to merge / Needs more work / Needs manual testing

**6c. Handle Verification Result**

- **PASS + FIXED + No Regression** → proceed to Phase 7
- **FAIL or REGRESSION_FOUND = Yes** →
  ```
  Verification failed:
    Test status: <TEST_STATUS>
    Fix status: <FIX_STATUS>
    Regression: <REGRESSION_FOUND>

  Options:
    retry  — Re-dispatch bug-fixer with failure context (attempt <N>/2)
    stop   — Halt for manual review
  ```
  If user chooses "retry" and attempts < 2:
  - Feed the verification failure details back to bug-fixer (Phase 5b)
  - Then re-run Phase 5.5 + Phase 6
  - Max 2 retry rounds; after that, halt and report

- **SKIPPED** (no TEST_COMMAND) → note in report, proceed to Phase 7

---

### Phase 7: Report

```
============================================================
Bug Fix Complete — Four-Stage Pipeline Summary

Bug: <BUG_SUMMARY>
Source: <GitHub Issue #N / User description>

[Locate]  File: <SUSPECTED_FILE>:<SUSPECTED_LINE>
          Function: <SUSPECTED_FUNCTION>
          Confidence: <CONFIDENCE>

[Analyze] Root Cause: <ROOT_CAUSE>
          Category: <BUG_CATEGORY>
          Severity: <SEVERITY>

[Fix]     Changes:
            - <file>: <what was changed>
          Explanation: <FIX_EXPLANATION>

[Verify]  Tests: <TEST_STATUS>
          Fix: <FIX_STATUS>
          Regression: <REGRESSION_FOUND>
          Verdict: <FINAL_VERDICT>

Branch: <fix/branch-name or current branch>

Next steps:
  - [ ] Verify the fix manually with reproduction steps
  - [ ] Run full test suite if not done
  - [ ] Commit and push when satisfied
  - [ ] Close GitHub Issue #N (if applicable)
============================================================
```

If the bug came from a GitHub Issue, offer to add a comment:
```
Add a comment to Issue #N with the diagnosis and fix? (yes/no)
```

If yes, post a comment summarizing the root cause and fix via GitHub MCP tool.

---

## Error Handling

- **No logs found**: Set `LOG_FINDINGS = "N/A"`, skip Phase 2, proceed to Phase 3
- **Cannot reproduce from description**: Ask user for more details (max 2 rounds)
- **Locator cannot find source**: Ask user for hints; max 1 retry, then proceed with best guess
- **Analyzer disagrees with locator**: Analyzer may override location — its report takes precedence
- **Fix breaks build/tests**: Verifier reports failure → retry loop (max 2 rounds back to Fixer)
- **Verifier reports regression**: Show rollback plan from Fixer, ask user whether to revert or adjust
- **Multiple possible root causes**: Analyzer presents all candidates ranked by likelihood, user chooses
- **Subagent timeout**: Follow the timeout handling procedure (split task, re-dispatch, halt after 2 failures)
